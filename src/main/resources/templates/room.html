<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="/css/style.css"/>
    <title>Room</title>
</head>
<body style="margin: 0; height: 100%; overflow: hidden">

<div id="container">

    <span id="p1" style="color:dodgerblue; margin-left: 0;" th:text="${username}"></span><span>: </span><span
        id="myScore">0</span>
    <span style="color:red">vs</span>
    <span id="p2">Player2</span><span>: </span><span id="enemyScore">0</span>

    <button id="help_button">HELP</button>
    <button id="player_change">Player Change</button>
    <div id="myProgress">
        <div id="myBar">
            <div id="label">0%</div>
        </div>
    </div>
    <button id="hit_button" style="width :60pt;">HIT BALL</button>
    <div id="canv">
        <canvas>
        </canvas>
    </div>
</div>
<!--    <audio style="position: absolute; right:0; bottom: 0;" src="../sounds/bgm.mp3" autoplay controls></audio>-->

<script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
<!--<script type="text/javascript" th:src="@{/js/billiard.js}"></script>-->
<!--<script type="text/javascript" th:src="@{/js/event.js}"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.1.4/sockjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
<script th:inline="javascript">

    let stompClient = null;
    let username = null;
    let myName = document.getElementById("p1");
    let enemyName = document.getElementById("p2");
    let isFirstPlayer = true;

    window.addEventListener('load', function () {
        connect();
    });

    function getCookie(cookieName) {
        let cookieValue = null;
        if (document.cookie) {
            const array = document.cookie.split((escape(cookieName) + '='));
            if (array.length >= 2) {
                let arraySub = array[1].split(';');
                cookieValue = unescape(arraySub[0]);
            }
        }
        return cookieValue;
    }

    function connect() {
        username = getCookie("username")
        if (username) {
            myName.innerHTML = username;
            let socket = new SockJS('/ws');
            stompClient = Stomp.over(socket);
            stompClient.connect({}, onConnected, onError);
        }
    }

    function onConnected() {
        stompClient.subscribe('/topic/public', onMessageReceived);
        stompClient.send("/app/chat.addUser", {}, JSON.stringify({sender: username, type: 'JOIN'}));
    }

    function onError() {
        alert("error");
    }

    function sendMessage() {


        if (stompClient) {
            let chatMessage = {
                sender: username,
                content: "content",
                type: 'CHAT'
            };

            stompClient.send("/app/chat.sendMessage", {}, JSON.stringify(chatMessage));
        }
    }

    function sendPresent() {
        if (stompClient) {
            let chatMessage = {
                sender: username,
                type: 'PRESENT'
            };
            stompClient.send("/app/chat.sendMessage", {}, JSON.stringify(chatMessage));
        }
    }

    function sendShot(dx, dy) {
        if (stompClient) {
            let chatMessage = {
                sender: username,
                type: 'SHOT',
                dx: dx,
                dy: dy
            };
            stompClient.send("/app/chat.sendMessage", {}, JSON.stringify(chatMessage));
        }
    }

    function onMessageReceived(payload) {

        let message = JSON.parse(payload.body);
        if (message.type === 'JOIN' && message.sender !== username) {
            enemyName.innerHTML = message.sender;
            sendPresent();
        } else if (message.type === 'LEAVE') {
            alert(enemyName.innerHTML + " left the game.");
        } else if (message.sender !== username && message.type === 'PRESENT') {
            enemyName.innerHTML = message.sender;
            myTurn = 1;
            isFirstPlayer = false;
            switchName();
        } else if (message.sender !== username && message.type === 'SHOT') {
            // HitBall(message.content.dx, message.content.dy);
            remote_cue_execute(message.dx, message.dy);
        } else if (message.type === 'DONE' && message.sender !== username) {

        }else if (message.type === 'CUE' && message.sender !== username) {
            cue.degree = message.cueDegree;
            draw();
        }
    }

</script>
<script>
    let help = document.getElementById("help_button");
    let hit = document.getElementById("hit_button");
    let player = document.getElementById("player_change");
    let elem = document.getElementById("myBar");
    let mouseX = 9999, mouseY = 9999, distX, distY;
    let nowdegree = 0;
    let cursor_grab = "url(DATA URI), move";
    let cursor_drag = "url(DATA URI), move";
    let degreeToRadian = Math.PI / 180;
    let canvas = document.querySelector('canvas'),
        ctx = canvas.getContext('2d'),
        w = window.innerWidth,
        h = window.innerHeight,
        points = 4,
        colors = ['#feca28', '#f8f6ea', '#e51515', '#e51515'],
        balls = [],
        table,
        mouse = {
            down: false,
            button: 1,
            x: 0,
            y: 0,
            px: 0,
            py: 0
        },
        elasticity = .8,
        refreshHz = 60,
        velocityCutoff = 0.01,
        bounceLoss = .85,
        cue,
        tableFriction = 0.00003;
    canvas.width = w;
    canvas.height = h;
    let power = 0;
    xlocations = [810, 200, 810, 270];
    ylocations = [190, 275, 275, 275];
    nowPlayer = 0;
    shootend = false;
    let scoreinfo = [0, 0];


    window.requestAnimFrame = (function () {
        return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 1000 / refreshHz);
            };
    })();

    window.onload = function () {
        canvas.addEventListener('mousemove', updateCanvas, false);    //움직일때
        canvas.addEventListener('mousedown', startDrag, false); // 버튼을 누를때
        canvas.addEventListener('mouseup', stopDrag, false);  // 버튼을 놓을때

        // player.addEventListener('click', playerChange, false);
        hit.addEventListener('mousedown', startGauge, false);
        hit.addEventListener('mouseup', stopGauge, false);
        help.addEventListener('mousedown', help_alert, false);

        document.addEventListener("keydown", keyEvent1);
        document.addEventListener("keyup", keyEvent2);

        draw();
    };

    let Cue = function (ball) {
        this.x = ball.x + 60;
        this.y = ball.y + 60;
        this.degree = 0;
        this.mouse = false;
        this.drag = false;
        this.visible = true;
    }

    function draw_cue() {

        if (cue.visible) {
            ctx.clearRect(0, 0, w, h);
            table.draw();
            for (let i = 0; i < points; i++) {
                let temp = balls[i];
                temp.TestImpact();
                temp.Update(table);
                temp.draw(table);
            }

            let degree = cue.degree * degreeToRadian;
            let x1_start = cue.x + 40 * Math.cos(degree + degreeToRadian * 5);
            let x2_start = cue.x + 40 * Math.cos(degree - degreeToRadian * 5);
            let x3_start = cue.x + 50 * Math.cos(degree + degreeToRadian * 5);
            let x4_start = cue.x + 50 * Math.cos(degree - degreeToRadian * 5);
            let y1_start = cue.y + 40 * Math.sin(degree + degreeToRadian * 5);
            let y2_start = cue.y + 40 * Math.sin(degree - degreeToRadian * 5);
            let y3_start = cue.y + 50 * Math.sin(degree + degreeToRadian * 5);
            let y4_start = cue.y + 50 * Math.sin(degree - degreeToRadian * 5);


            ctx.beginPath();
            ctx.moveTo(x1_start, y1_start);
            ctx.lineTo(x2_start, y2_start);
            ctx.lineTo(x4_start, y4_start);
            ctx.lineTo(x3_start, y3_start);
            ctx.fillStyle = "#f8f6ea";
            ctx.fill();

            let x1_end = cue.x + 700 * Math.cos(degree + degreeToRadian * 0.6);
            let x2_end = cue.x + 700 * Math.cos(degree - degreeToRadian * 0.6);
            let y1_end = cue.y + 700 * Math.sin(degree + degreeToRadian * 0.6);
            let y2_end = cue.y + 700 * Math.sin(degree - degreeToRadian * 0.6);


            ctx.fillStyle = "#f6dfbd";
            ctx.beginPath();
            ctx.save();
            ctx.shadowOffsetX = 10;
            ctx.shadowOffsetY = 10;
            ctx.shadowColor = "rgba(0,0,0,.3)";
            ctx.shadowBlur = 5;
            ctx.moveTo(x1_start, y1_start);
            ctx.lineTo(x2_start, y2_start);
            ctx.lineTo(x2_end, y2_end);
            ctx.lineTo(x1_end, y1_end);
            ctx.isPointInPath(mouseX, mouseY) ? cue.mouse = true : cue.mouse = false;  //현재 경로에 포함되있는지 확인
            ctx.fill();

            let x1_middle = cue.x + 520 * Math.cos(degree + degreeToRadian * 0.6);
            let x2_middle = cue.x + 520 * Math.cos(degree - degreeToRadian * 0.6);
            let x3_middle = cue.x + 450 * Math.cos(degree);
            let x4_middle = cue.x + 680 * Math.cos(degree + degreeToRadian * 0.6);
            let x5_middle = cue.x + 680 * Math.cos(degree - degreeToRadian * 0.6);

            let y1_middle = cue.y + 520 * Math.sin(degree + degreeToRadian * 0.6);
            let y2_middle = cue.y + 520 * Math.sin(degree - degreeToRadian * 0.6);
            let y3_middle = cue.y + 450 * Math.sin(degree);
            let y4_middle = cue.y + 680 * Math.sin(degree + degreeToRadian * 0.6);
            let y5_middle = cue.y + 680 * Math.sin(degree - degreeToRadian * 0.6);

            ctx.fillStyle = "#1a1a18";

            ctx.beginPath();
            ctx.moveTo(x1_middle, y1_middle);
            ctx.lineTo(x3_middle, y3_middle);
            ctx.lineTo(x2_middle, y2_middle);
            ctx.lineTo(x5_middle, y5_middle);
            ctx.lineTo(x4_middle, y4_middle);
            ctx.fill();
            ctx.closePath();

            ctx.restore();
            draw_guide_1();

        }
    }


    let Table = function () {
        this.xPos = 60;
        this.yPos = 60;
        this.width = 1080;
        this.height = 550;
    }


    Table.prototype.draw = function () {
        let tw = this.width + 120;
        let th = this.height + 120;

        ctx.setLineDash([]);
        ctx.fillStyle = "#6a5746";
        ctx.fillRect(0, 0, tw, th);
        ctx.fillStyle = "#3456af";
        ctx.fillRect(45, 45, tw - 90, th - 90);
        ctx.fillStyle = "#4370d7";
        ctx.fillRect(60, 60, tw - 120, th - 120);

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(60, 60);
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.moveTo(tw, 0);
        ctx.lineTo(tw - 60, 60);
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.moveTo(0, th);
        ctx.lineTo(60, th - 60);
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.moveTo(tw, th);
        ctx.lineTo(tw - 60, th - 60);
        ctx.stroke();
        ctx.closePath();

        ctx.fillStyle = "#b0b0b0";

        for (let i = 1; i <= 7; i++) {
            ctx.beginPath();
//arc(중심점x, 중심점y, 반지름, 시작각도, 끝각도, 방향)
//true : 반시계 방향 , false : 시계 방향
            ctx.arc(60 + (tw - 120) / 8 * i, 30, 5, 0, Math.PI * 2, true);
            ctx.strokeStyle = "#0";
            ctx.fill();
            ctx.closePath();

            ctx.beginPath();
            ctx.arc(60 + (tw - 120) / 8 * i, th - 30, 5, 0, Math.PI * 2, true);
            ctx.strokeStyle = "#0";
            ctx.fill();
            ctx.closePath();
        }

        for (let i = 1; i <= 3; i++) {
            ctx.beginPath();
            ctx.arc(30, 60 + (th - 120) / 4 * i, 5, 0, Math.PI * 2, true);
            ctx.strokeStyle = "#0";
            ctx.fill();
            ctx.closePath();

            ctx.beginPath();
            ctx.arc(tw - 30, 60 + (th - 120) / 4 * i, 5, 0, Math.PI * 2, true);
            ctx.strokeStyle = "#0";
            ctx.fill();
            ctx.closePath();
        }
    }


    let Ball = function (i) {
        this.r = 20;
        this.x = xlocations[i % points];
        this.y = ylocations[i % points];
        this.opacity = 1;
        this.xVelocity = 0;
        this.yVelocity = 0;
        this.xAccel = 0;
        this.yAccel = 0;
        this.bounceLoss = bounceLoss;
        this.tableFriction = tableFriction;
        this.c = colors[i % points];
        this.index = i;
        this.move = false;
        this.red1 = false;
        this.red2 = false;
        this.loss = false;
    }

    Ball.prototype.draw = function (table) {
        ctx.fillStyle = this.c;
        ctx.globalAlpha = this.opacity;
        ctx.beginPath();
        ctx.save();
        ctx.shadowOffsetX = 10;
        ctx.shadowOffsetY = 10;
        ctx.shadowColor = "rgba(0,0,0,.3)";
        ctx.shadowBlur = 5;
        ctx.arc(this.x + table.xPos,
            this.y + table.yPos,
            this.r, 0, Math.PI * 2, true);
        ctx.fill();
        ctx.closePath();
        ctx.restore();
    };

    Ball.prototype.Update = function (table) {
        let dT = 1000 / refreshHz;
        this.xAccel = this.xVelocity * -this.tableFriction * dT;
        this.yAccel = this.yVelocity * -this.tableFriction * dT;
        this.yVelocity += this.yAccel * dT;
        this.xVelocity += this.xAccel * dT;
        this.y += this.yVelocity * dT;
        this.x += this.xVelocity * dT;

        let bounce = false;
        if (this.y >= table.height - this.r) // Ball at bottom edge
        {
            this.y = table.height - this.r;
            this.yVelocity = -this.yVelocity;
            this.yAccel = -this.yAccel;
            bounce = true;
        } else if (this.y <= this.r) // Ball at top edge
        {
            this.y = this.r;
            this.yVelocity = -this.yVelocity;
            this.yAccel = -this.yAccel;
            bounce = true;
        }

        if (this.x >= table.width - this.r) // Ball at right edge
        {
            // Make sure there is no overlap over the edge at all
            //  because x is probably past the edge by < velocity
            this.x = table.width - this.r;
            // "Bounce" it
            this.xVelocity = -this.xVelocity;
            this.xAccel = -this.xAccel;
            bounce = true;
        } else if (this.x <= this.r) // Ball at left edge
        {
            this.x = this.r;
            this.xVelocity = -this.xVelocity;
            this.xAccel = -this.xAccel;
            bounce = true;
        }

        // Update velocity
        if (bounce) {
            this.xVelocity *= this.bounceLoss;
            this.yVelocity *= this.bounceLoss;
        }

        if (Math.abs(this.xVelocity) + Math.abs(this.yVelocity) < velocityCutoff) {
            this.yVelocity = 0;
            this.yAccel = 0;
            this.xVelocity = 0;
            this.xAccel = 0;
        }

    };

    Ball.prototype.Strike = function (xImpact, yImpact) {
        this.xVelocity += xImpact;
        this.yVelocity += yImpact;
    };

    function CollideBalls(ball, ball2) {
        // 충돌 감지

        let lossball;
        //sound_collision.play();

        lossball = (nowPlayer + 1) % 2;

        if (ball === balls[nowPlayer]) {
            if (ball2 === balls[lossball])
                balls[nowPlayer].loss = true;
            if (ball2 === balls[2])
                balls[nowPlayer].red1 = true;
            if (ball2 === balls[3])
                balls[nowPlayer].red2 = true;
        }

        let Del = ball2.r + ball.r;
        let dX = ball2.x - ball.x;
        let dY = ball2.y - ball.y;
        let dVX = ball2.xVelocity - ball.xVelocity;
        let dVY = ball2.yVelocity - ball.yVelocity;
        let dSq = dX * dX + dY * dY;
        let alpha = (1 + elasticity) / 2 * (dX * dVX + dY * dVY) / dSq;


        ball.xVelocity += dX * alpha;
        ball.yVelocity += dY * alpha;
        ball2.xVelocity -= dX * alpha;
        ball2.yVelocity -= dY * alpha;

        let DDist = ((Del + 1) / Math.sqrt(dSq) - 1) / 2;
        ball.x -= dX * DDist;
        ball.y -= dY * DDist;
        ball2.x += dX * DDist;
        ball2.y += dY * DDist;

    }

    Ball.prototype.TestImpact = function () {
        for (let i = this.index + 1; i < points; i++) {
            let ball = balls[i];
            if (Dist(this.x, this.y, ball.x, ball.y) > this.r + ball.r) {
                continue;
            }
            CollideBalls(this, ball);
        }
    }


    function HitBall() {
        d_power = power * 0.75;

        let mouseDownX = cue.x - d_power * Math.cos(cue.degree * degreeToRadian);
        let mouseDownY = cue.y - d_power * Math.sin(cue.degree * degreeToRadian);

        let dX = mouseDownX - balls[nowPlayer].x - 60;
        let dY = mouseDownY - balls[nowPlayer].y - 60;
        shootend = true;
        balls[nowPlayer].Strike(dX / 50.0, dY / 50.0);
        sendShot(dX, dY);
    }

    function remoteHitBall() {
        shootend = true;
        balls[nowPlayer].Strike(remoteDx / 50.0, remoteDy / 50.0);
    }

    function Dist(x1, y1, x2, y2) {
        let diffX = x2 - x1;
        let diffY = y2 - y1;
        return Math.sqrt((diffX * diffX) + (diffY * diffY));
    }


    (function init() {

            for (let i = 0; i < points; i++) {
                balls.push(new Ball(i));
            }

            for (let i = this.index + 1; i < points; i++) {
                let ball = balls[i];
                if (Dist(this.x, this.y, ball.x, ball.y) > this.r + ball.r) {
                    continue;
                }
            }

            table = new Table();
            cue = new Cue(balls[nowPlayer]);
        }
    )();


    function draw() {
        let stop = true;
        ctx.clearRect(0, 0, w, h);
        table.draw();
        for (let i = 0; i < points; i++) {
            let temp = balls[i];
            temp.TestImpact();
            temp.Update(table);
            temp.draw(table);
        }

        for (let i = 0; i < points; i++) {
            let temp = balls[i];
            stop = stop && (temp.xVelocity === 0 && temp.yVelocity === 0)
        }


        if (stop) {//공이 모두 멈췄을때
            cue.x = balls[nowPlayer].x + 60;
            cue.y = balls[nowPlayer].y + 60;
            cue.visible = true;
            hit.disabled = false;
            player.disabled = false;
            waite = true;
            stop = !stop;

            if (shootend) {
                getscore();
                shootend = false;
            }
        } else {// 공이 움직일때
            hit.disabled = true;
            player.disabled = true;
        }

        draw_cue();

        if (!cue.visible) {
            requestAnimFrame(draw);
        }
    }

</script>

<script>
    // let sound_hit = new Audio('../sounds/hit.mp3');
    // let sound_collision = new Audio('../sounds/collision.mp3');
    let gauge = 0;
    let one = 0.1;
    let id;
    // let power = 0;
    let tempX;
    let tempY;
    let TimerID;
    let remoteTimerID;
    let i = 0;
    let isfirst = true;
    let guide_x;
    let guide_y;
    let myTurn = 0;
    let remoteDx = 0;
    let remoteDy = 0;

    function findOffset(obj) {
        let curX = 0;
        let curY = 0;
        if (obj.offsetParent) {
            do {
                curX += obj.offsetLeft;
                curY += obj.offsetTop;
            } while (obj === obj.offsetParent);
            return {x: curX, y: curY};
        }
    }

    function updateCanvas(e) {
        let pos = findOffset(canvas);

        mouseX = e.pageX - pos.x;   // 마우스의 현재 좌표
        mouseY = e.pageY - pos.y;

        nowdegree = 180 * Math.atan2(mouseX - cue.x, mouseY - cue.y) / Math.PI;

        if (cue.mouse && !cue.drag) {
            canvas.style.cursor = cursor_grab;
        } else if (cue.drag) {
            canvas.style.cursor = cursor_drag;
        } else {
            canvas.style.cursor = 'auto';
        }
        if (cue.drag) {
            cue.degree = -(nowdegree - 90);
        }

        draw_cue();
    }

    function startDrag() {
        if (cue.mouse === true) {
            cue.drag = true;
            distX = mouseX - cue.x;
            distY = mouseY - cue.y;


        }
    }

    function stopDrag() {
        one = 0.1;
        if (cue.drag === true) {
            cue.drag = false;
        }
    }

    function frame() {
        one = one + 0.007;
        gauge += one;
        if (gauge >= 100.0) {
            one = -one;
        }

        if (gauge <= 0) {
            one = 0.1;
            one = Math.abs(one);
        }
        elem.style.width = gauge + '%';
        document.getElementById("label").innerHTML = gauge.toFixed(1) + '%';
    }

    function startGauge() {
        id = setInterval(frame, 10);
        waitkey = false;
    }

    function stopGauge() {
        clearInterval(id);
        power = gauge;
        gauge = 0;
        elem.style.width = gauge + '%';
        document.getElementById("label").innerHTML = gauge.toFixed(1) + '%';
        hit.disabled = true;
        cue_execute();
        waitkey = true;
    }

    function cue_motion() {
        i++;
        cue.x = cue.x + i * Math.cos(degreeToRadian * cue.degree);
        cue.y = cue.y + i * Math.sin(degreeToRadian * cue.degree);

        draw_cue();
        if (i >= 100) {
            clearInterval(TimerID);
            cue.x = tempX - 20 * Math.cos(degreeToRadian * cue.degree);
            cue.y = tempY - 20 * Math.sin(degreeToRadian * cue.degree);
            draw_cue();
            //sound_hit.play();
            i = 0;
            // setTimeout(function () {
            cue.visible = false;
            HitBall();
            draw();
            // }, 500);

        }

        cue.x = tempX;
        cue.y = tempY;
    }

    function remote_cue_motion() {
        i++;
        cue.x = cue.x + i * Math.cos(degreeToRadian * cue.degree);
        cue.y = cue.y + i * Math.sin(degreeToRadian * cue.degree);

        draw_cue();
        if (i >= 100) {
            clearInterval(remoteTimerID);
            cue.x = tempX - 20 * Math.cos(degreeToRadian * cue.degree);
            cue.y = tempY - 20 * Math.sin(degreeToRadian * cue.degree);
            draw_cue();
            //sound_hit.play();
            i = 0;
            // setTimeout(function () {
            cue.visible = false;
            remoteHitBall();
            draw();
            // }, 500);

        }

        cue.x = tempX;
        cue.y = tempY;
    }

    function switchName() {
        var temp = enemyName.innerHTML
        enemyName.innerHTML = myName.innerHTML;
        myName.innerHTML = temp;
    }

    function cue_execute() {

        tempX = cue.x;
        tempY = cue.y;

        TimerID = setInterval(cue_motion, 10);
    }

    function remote_cue_execute(dx, dy) {
        remoteDx = dx;
        remoteDy = dy;
        remoteTimerID = setInterval(remote_cue_motion, 10);
    }

    function draw_guide_1() {
        let gx = balls[nowPlayer].x + 60;
        let gy = balls[nowPlayer].y + 60;

        let degree = cue.degree * degreeToRadian;

        let point_x = gx - 20 * Math.cos(degree);
        let point_y = gy - 20 * Math.sin(degree);

        //case left wall
        let guide_left_x = 60;
        let guide_left_y = gy - Math.tan(degreeToRadian * cue.degree) * (point_x - 60);

        //case right wall
        let guide_right_x = 1140;
        let guide_right_y = gy - Math.tan(degreeToRadian * cue.degree) * (point_x - 1140);

        //case top wall
        let guide_top_x = gx - Math.tan(degreeToRadian * (90 - cue.degree)) * (point_y - 60);
        let guide_top_y = 60;

        //case bottom wall
        let guide_bottom_x = gx - Math.tan(degreeToRadian * (90 - cue.degree)) * (point_y - 610);
        let guide_bottom_y = 610;


        if (isfirst) {
            guide_x = guide_left_x;
            guide_y = guide_left_y;
        }


        //case left to top
        if (guide_y <= 60 && (guide_x > 60 || guide_x <= 1140)) {
            guide_x = guide_top_x; //가변값
            guide_y = guide_top_y; //610
            isfirst = false;
        }

        //case top to right
        if (guide_x >= 1140 && (guide_y > 60 || guide_y <= 610)) {
            guide_x = guide_right_x; // 1140
            guide_y = guide_right_y; // 가변값
        }

        //case right to bottom
        if (guide_y >= 610 && (guide_x >= 60 || guide_x < 1140)) {
            guide_x = guide_bottom_x; //가변값
            guide_y = guide_bottom_y; //610
        }

        //cace bottom to left
        if (guide_x <= 60 && (guide_y >= 60 || guide_y < 610)) {
            guide_x = guide_left_x; //60
            guide_y = guide_left_y; //가변값
            isfirst = false;
        }


        ctx.setLineDash([5, 10]);
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.moveTo(point_x, point_y);
        ctx.lineTo(guide_x, guide_y);
        ctx.stroke();
        ctx.closePath();
    }

    function playerChange() {
        myScore = document.getElementById("myScore");
        enemyScore = document.getElementById("enemyScore");
        nowPlayer++;
        nowPlayer = nowPlayer % 2;

        if (nowPlayer === 0) {
            enemyName.style.color = "lightgrey";
            myName.style.color = "dodgerblue";
        } else {
            enemyName.style.color = "dodgerblue";
            myName.style.color = "lightgrey";
        }
        myScore.innerHTML = String(scoreinfo[0]);
        enemyScore.innerHTML = String(scoreinfo[1]);

        draw();
    }

    let waitkey = true;
    let waite = true;

    function keyEvent1(e) {
        player.disabled = true;
        if (waitkey) {
            if (e.keyCode === 38) { //up arrow
                cue.degree--;
            } else if (e.keyCode === 40) { //down arrow
                cue.degree++;
            } else if (e.keyCode === 37) { //left arrow
                cue.degree -= 3;
            } else if (e.keyCode === 39) { //right arrow
                cue.degree += 3;
            } else if (e.keyCode === 67) { //c
                // playerChange();
            } else if (e.keyCode === 32 && waite && myTurn === nowPlayer) { //w
                startGauge();
                waite = false;
            }
            sendCue(cue.degree);
            draw();
        }
    }

    function keyEvent2(e) {
        if (e.keyCode === 32 && waite && myTurn === nowPlayer) { //w
            stopGauge();
            waite = false;
            waitkey = true;
        }
    }

    function sendDone() {
        if (stompClient) {
            let chatMessage = {
                sender: username,
                type: 'DONE'
            };
            stompClient.send("/app/chat.sendMessage", {}, JSON.stringify(chatMessage));
        }
    }

    function sendCue(degree) {
        if (stompClient) {
            let chatMessage = {
                sender: username,
                cueDegree: degree,
                type: 'CUE'
            };
            stompClient.send("/app/chat.sendMessage", {}, JSON.stringify(chatMessage));
        }
    }



    function getscore() {
        let text;
        let turnover = false;
        if (!balls[nowPlayer].loss) //적구를 맞지 않았을때
        {
            if (balls[nowPlayer].red1 && balls[nowPlayer].red2) {
                scoreinfo[nowPlayer]++; //득점
                text = "Nice Shoot!";
            } else if (balls[nowPlayer].red1 || balls[nowPlayer].red2) {
                //무실점 무득점
                text = "Let's do better!";
                turnover = true;
                sendDone();
            } else {
                text = "Oh My God !!"; //실점
                if (scoreinfo[nowPlayer] > 0)
                    scoreinfo[nowPlayer]--;
                turnover = true;
                sendDone();
            }
        } else {
            text = "Oh My God !!"; //실점
            if (scoreinfo[nowPlayer] > 0)
                scoreinfo[nowPlayer]--;
            turnover = true;
            sendDone();
        }   //오류나는 이유 나우공이 바뀌기전에 공이 맞은정보가 초기화 되야함
        //또한 메시지도 즉시 출력됨

        balls[nowPlayer].red1 = false;  //공이 맞은 정보 초기화
        balls[nowPlayer].red2 = false;
        balls[nowPlayer].loss = false;

        if (turnover) {
            nowPlayer = ++nowPlayer % 2;// 차례변경
            cue.x = balls[nowPlayer].x + 60;
            cue.y = balls[nowPlayer].y + 60;
        }

        if (nowPlayer === 0) {
            enemyName.style.color = "lightgrey";
            myName.style.color = "dodgerblue";
        } else {
            enemyName.style.color = "dodgerblue";
            myName.style.color = "lightgrey";
        }
        myScore.innerHTML = String(scoreinfo[0]);
        enemyScore.innerHTML = String(scoreinfo[1]);


        ctx.clearRect(0, 0, w, h);
        table.draw();

        setTimeout(function () {
            ctx.font = 'italic 100px calibri';
            ctx.fillText(text, 250, 250);
        }, 500)


    }

    function help_alert() {
        swal(
            "How to Play",
            "Mouse Control\n" +
            "1. You can adjust the angle by dragging and dropping the cue\n" +
            "2. You can adjust the force by pressing the mouse on the hit button\n\n" +

            "Key Control\n" +
            "1. Left or Right arrow (←, →) : Detailed angle adjustment\n" +
            "2. Up or Down arrow (↑, ↓) : Large angle adjustment\n" +
            "3. Space Bar : same as pressing the hit button\n" +
            "4. Key-C : Player Change",

            "info"
        );
    }
</script>
</body>
</html>